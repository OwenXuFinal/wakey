#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_ADXL345_U.h>
#include <SoftwareSerial.h>

//TILT DETECTION LOGIC AND RECALIBRATION FUNCTIONS WERE GENERATED BY CHATGPT
Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345);

const float TILT_THRESHOLD = 30.0; 
const unsigned long TILT_DURATION = 5000; 
const int buzzerPin = 8;

// HC-05 Bluetooth Module connected on pins 10 (RX), 11 (TX)
SoftwareSerial BTSerial(10, 11); // RX, TX

unsigned long tiltStartTime = 0;
bool tiltDetected = false;
bool alertTriggered = false;

// Recalibration offset variables
float pitchOffset = 0;
float rollOffset = 0;

void setup() {
  Serial.begin(9600);
  BTSerial.begin(9600);
  while (!Serial);

  pinMode(buzzerPin, OUTPUT);
  digitalWrite(buzzerPin, LOW);

  if (!accel.begin()) {
    Serial.println("No ADXL345 detected");
    while (1);
  }

  accel.setRange(ADXL345_RANGE_16_G);
  Serial.println("ADXL345 tilt monitoring...");
  BTSerial.println("Bluetooth tilt monitoring started");
}

void loop() {
  if (BTSerial.available()) {
    String command = BTSerial.readStringUntil('\n');
    command.trim();
    if (command == "recalibrate") {
      recalibrate();
    }
  }

  sensors_event_t event;
  accel.getEvent(&event);

  float ax = event.acceleration.x;
  float ay = event.acceleration.y;
  float az = event.acceleration.z;

  float pitch = atan2(ax, sqrt(ay * ay + az * az)) * 180.0 / PI - pitchOffset;
  float roll  = atan2(ay, sqrt(ax * ax + az * az)) * 180.0 / PI - rollOffset;

  String dataStr = "PITCH:" + String(pitch, 2) + ",ROLL:" + String(roll, 2);
  Serial.println(dataStr);
  BTSerial.println(dataStr);

  if (abs(pitch) > TILT_THRESHOLD || abs(roll) > TILT_THRESHOLD) {
    if (!tiltDetected) {
      tiltStartTime = millis();
      tiltDetected = true;
      alertTriggered = false;
    } else {
      unsigned long elapsed = millis() - tiltStartTime;
      if (elapsed > TILT_DURATION && !alertTriggered) {
        Serial.println("ALERT");
        BTSerial.println("ALERT");
        tone(buzzerPin, 1000);
        alertTriggered = true;
      }
    }
  } else {
    tiltDetected = false;
    alertTriggered = false;
    noTone(buzzerPin);
  }

  delay(50);
}

void recalibrate() {
  sensors_event_t event;
  accel.getEvent(&event);

  float ax = event.acceleration.x;
  float ay = event.acceleration.y;
  float az = event.acceleration.z;

  pitchOffset = atan2(ax, sqrt(ay * ay + az * az)) * 180.0 / PI;
  rollOffset  = atan2(ay, sqrt(ax * ax + az * az)) * 180.0 / PI;

  Serial.println("Recalibrated");
  BTSerial.println("Recalibrated");
}